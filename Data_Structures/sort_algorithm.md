## Sorting Algorithm

- 정렬(sort)은 주어진 레코드를 원하는 키 필드 값의 순서대로 나열하는 작업을 말한다.
- 정렬은 레코드의 리스트를 주메모리에서 처리하는 내부 정렬(internal sort)과 하드 디스크와 같은 별도의 보조 기억장치를 사용하여 처리하는 외부 정렬(external sort)로 구분한다.
- 대표적인 내부 정렬 알고리즘의 종류를 알아보자.



## 1. 선택 정렬(Selection Sort)

- 알고리즘

```c
for (n개의 원소 각각에 대해 반복){
	기준 원소를 포함하여 최소/최대값을 탐색한다.
	기준 원소와 최소/최대값 원소를 교환한다.
	정렬된 원소를 제외한 나머지 원소에 대해 위 과정을 반복한다.
}
```

- Time Complexity : n개의 원소를 n번 비교하기 때문
  $$
  O(n^2)
  $$
  

- Space Complexity : 단 하나의 배열에서만 정렬을 진행하기 때문
  $$
  O(n)
  $$
  

- 예시

```c
void selectSort(int list[], int n){
	int i, j, min, temp;
	for(i=0; i<n-1; i++){
		min = i;
		for(j=i+1; j<n; j++){
			if(list[j] < list[min])
				min = j;
		}
		temp = list[i];
		list[i] = list[min];
		list[min] = temp;
	}
}
```



## 2. 버블 정렬(Bubble Sort)

- 알고리즘

  ```
  1. 가장 왼쪽의 인접한 두 수를 비교하여 왼쪽 수가 더 크면 오른쪽 수와 위치를 교환한다.
  2. 오른쪽으로 1칸을 이동하면서 같은 방식으로 두 수의 크기를 비교하여 교환하고 가장 오른쪽에 도달할 때까지 이 과정을 반복한다. (최대값이 오른쪽 끝에 도착)
  3. 오른쪽 끝에 최대값이 도달하였음으로 이 원소를 제외하고 나머지 원소에 대해서 비교 대상 원소가 1개가 남을 때까지 1번 과정부터 반복한다.
  ```

- Time Complexity : n개의 원소를 n번 비교하기 때문
  $$
  O(n^2)
  $$
  

- 중복해서 비교가 일어나기 때문에 입력의 크기(n)가 클수록 성능이 떨어진다.

- 예시

  ```c
  void bubbleSort(int list[], int n){
      int i, j, flag = 1;
      for(i=n-1; flag>0; i--){
          flag = 0;
          for(j=0; j<i; j++){
              if(list[j] > list[j+1]){
                  temp = list[j];
                  list[j] = list[j+1];
                  list[j+1] = temp;
                  flag = 1; //swap
              }
          }
      }
  }
  ```

  

## 3. 삽입 정렬(Insertion Sort)

- 알고리즘

  ```
  1. 리스트의 인덱스 0번 위치의 항목 한 개는 이미 정렬이 완료된 리스트로 취급한다.
  2. 정렬 리스트의 오른쪽에 있는 정렬되지 않은 원소(1번 위치의 원소)는 자신의 앞에 있는 원소와 크기를 비교하여 앞쪽 원소가 더 크면 자리를 바꾼다.
  3. 동일하게 2번 위치에 있는 원소도 왼쪽으로 전진하면서 자기 자리를 찾을 때까지 왼쪽으로 전진한다.
  4. 이 과정을 더 이상 비교 대상 원소가 없을 때까지 반복한다.
  ```

- Time Complexity 

  : 최상의 경우, 이미 정렬이 완료 되어 있을 때
  $$
  O(n)
  $$
  

  : 최악의 경우, 원소들이 역순으로 되어 있을 때
  $$
  O(n^2)
  $$
  

- 예시

  ```c
  void insertionSort(int list[], int n){
      int i, j, next;
      for(i=1; i<n; i++){
          next = list[i];
          for(j=i-1; j>=0 && next<list[j]; j--)
              list[j+1] = list[j];
          list[j+1] = next;
      }
  }
  ```



## 4. 쉘 정렬(Shell Sort)

- 삽입 정렬의 원소들이 삽입될 때 이웃한 위치로만 이동하는 단점을 보안한 알고리즘이다.

- 삽입 정렬과 다르게 쉘 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.

- 알고리즘

  ```
  1. 정렬해야 할 리스트의 각 k(gap)번째 요소를 추출해서 부분 리스트를 만든다.
  -> gap 초기값 : 정렬할 수 / 2, 생성된 부분 리스트의 개수는 gap과 동일
  2. 반복문 실행 마다 k를 절반으로 줄인다. 즉, 반복문이 실행될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
  -> gap은 홀수가 좋음, 짝수일 경우 1을 더해 홀수로 만든다.
  3. k가 1이 될 때까지 반복한다.
  ```

- Time Complexticy : 평균적으로 소요되는 시간이고, 최악의 경우는 삽입 정렬과 동일하다.

$$
O (n^{3/2})
$$

- 장점

1. 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. (교환되는 원소들이 삽입 정렬보다 최종 위치에 가까워질 가능성이 높다.)
2. 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트이 개수가 1이 되면 쉘 정렬은 기본적으로 삽입 정렬보다 더욱 빠르게 수행된다.
3. 알고리즘이 간단하다.

- 예시

  ```c
  void shellSort(int list[], int n){
      int i, j, gap, temp;
      for(gap = n/2; gap>0; gap/=2){
          if(gap % 2 == 0) gap++;
          for(i = gap; i<n; i++){
              temp = list[i];
              for(j=i; j>=gap; j-=gap){
                  if(temp < list[j-gap])
                      list[j] = list[j-gap];
                  else break;
              }
              list[j] = temp;
          }
      }
  }
  ```



## 5. 퀵 정렬(Quick Sort)

